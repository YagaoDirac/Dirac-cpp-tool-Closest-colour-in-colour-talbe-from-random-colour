把rgb，uchar的24个位，交叉起来，这样当加1的时候，就可以在2x2x2的里面先走一遍。


调色盘的处理。每个颜色要保存uchar的rgb，和一个int，这个int就是xxxxxxxxrrrrrrrrggggggggbbbbbbbb的格式。方便做位掩码用。另外就是，调色盘必须要按这个数字排序。
此外还是要分通道排序。
struct里面就是2个东西，一个是特定的通道的值，一个是在原来的里面的索引
也就是说，对调色盘的搜索，可以是根据特定通道的值的（已排序），可以利用位掩码。当然还可以遍历，来直接用关系运算。

对rgb cube空间的处理，其实就是把rgb循环起来，做成一个int，他的内容是xxxxxxxxrgbrgbrgbrgbrgbrgbrgbrgb。这个新的数字是作为搜索的时候的index。这个index有2个好处，1是在做查询表的时候，也就是要遍历所有的rgb的值的时候，如果这个index的最后一位是1，那么他减1，肯定是在他的旁边，就可以做一个参考，参考的最近调色盘颜色，和新的（需要搜索最近调色盘颜色）的颜色，肯定很接近。如果最后一位不是1，那么往前找，如果最后是10，那么减2，如果是100，那么减4。到这儿都很好理解。如果最后是1000，减7，这个是相邻的，也就是r通道减1的那个颜色，而且一定是已经找到答案了的。如果是10000，减14，如果是100000，减28，好像还有一个7<<?的规律。更大的就具体研究一下。反正肯定是可以的。这样，新的搜索任务永远有一个超级好的参考，就肯定会很快。

然后就直接根据参考的距离，就在这个范围里面找
另外可能需要准备一个表，根据平方找平方根，int，升序，lower bound。吧？


















---------------------------------------
下面的是版本1



这个工具的作用是，把一个任意的rgb888格式的颜色（unsigned char），转换到，或者至少找到，在一个调色板里面，距离最近的颜色。

换句话说，这个工具里面有一个固定的调色板，里面存了一堆的颜色。在第一个版本里面是147个颜色，这些颜色也是rgb888（uchar）格式。输入一个颜色，计算这个颜色和所有的颜色的距离，找到距离最小的。如果并列，就随便一个就行。

其中，标准颜色，也就是所谓的调色板，是有可能变动的，所以算法必须要对任何一个调色板适用。而且这个调色板不保证有任何一个通道的颜色是一定有0或者255的。

现在的思路是，把调色板（标准颜色表），转换成一个比较好用的数据结构，从而在查表的过程中，更快，最后实在不行还是需要在一个很小的范围里面遍历一下的。反正尽量缩小包围圈肯定是对的。

现在的做法是
step1，将颜色分通道排序。
例如，按红色通道排序。结果里面需要记录，他们的红色通道的值，和在原数组里面的index。

step2，只看一个通道的情况下，把0到255的数值所需要遍历的颜色搜出来。
例如，（100，？，？）这个颜色，红色是100，那么在以红色排序的数组里面，其实只需要考虑很少几个颜色。我现在想的是，比100小的找最近的（包括并列），比100大的也找最近的（也包括并列）。把这些颜色的index保存起来。

step3，看到一个颜色的时候，把他的3个通道所需要考虑的颜色拿出来，遍历，算距离。

step4，step3里面的最优选择，的距离，做一个半径为这个距离的立方体（从输入颜色上，所有通道，正负这个值的floor），遍历里面的所有颜色。













